<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://rogeliolozano.github.io/blog</id>
    <title>Docs to connect the dots! Blog</title>
    <updated>2024-03-11T00:00:00.000Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://rogeliolozano.github.io/blog"/>
    <subtitle>Docs to connect the dots! Blog</subtitle>
    <icon>https://rogeliolozano.github.io/static/img/favicon.ico</icon>
    <entry>
        <title type="html"><![CDATA[What is a question?]]></title>
        <id>https://rogeliolozano.github.io/blog/What-is-a-question</id>
        <link href="https://rogeliolozano.github.io/blog/What-is-a-question"/>
        <updated>2024-03-11T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[I've come to realize that many of my concepts are highly intuitive and sometimes that works out well, but some other concepts are more complex and require a more elaborated mental model to support good conclusions.]]></summary>
        <content type="html"><![CDATA[<p>I've come to realize that many of my concepts are highly intuitive and sometimes that works out well, but some other concepts are more complex and require a more elaborated mental model to support good conclusions.</p>
<p>That is the case of questions. <strong>What is a question?</strong> I'll call this formulation WIQ</p>
<p>The first thing I realize when thinking about it is that is really difficult to analyze. First for the breadth and deepness of the ideas that come to my mind and second because my lake of known methodologies to approach endevours like this.</p>
<p>So I decide to go for it letting the flow of information in order to sink in my meaning of it. My intention is to create necessary conditions for the analysis but by no means I try to be exhaustive. It's beyond the current scope.</p>
<p>Second thing I note is my language limits (I recall Ludwig Wittgenstein aphorism: "Los límites de mi lenguaje son los límites de mi mundo" - I like the quote more in Spanish). When I noticed that WIQ is a self-referential formulation, then I inmediately fall into an ontological problem --&gt; Is there something I can compare to convey the idea of a self-referential formulation in the WIQ?</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="narratives">Narratives!!<a href="https://rogeliolozano.github.io/blog/What-is-a-question#narratives" class="hash-link" aria-label="Direct link to Narratives!!" title="Direct link to Narratives!!">​</a></h3>
<p>Perhaps is really hard to synthetize a comparable example for what I'm thinking and trying to communicate but narratives are great at transmitting highly dimensional-complex ideas!!</p>
<p>So, let's simplify it using a narrative because that is how I think I could undertand this situation better. Let's call a question X and an answer Y.</p>
<p>I'm something X whose existance is instanciated by a certain formulation of symbols (think of a symbol as a representation of some packet of information) that happend to be understood by other beings and generated by them in the first place. So I X, exist, conceptually but I'm only realized when formulated, and my essence is inferred by the realized instances. When I'm realized, many potential related questions coexist and are waiting to be formulated. Also, every time I'm formulated, infinite instances of something called Y, Y's are potentially created that are connected to my current formulation X' and intend to provide further information about X'.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="analysis">Analysis<a href="https://rogeliolozano.github.io/blog/What-is-a-question#analysis" class="hash-link" aria-label="Direct link to Analysis" title="Direct link to Analysis">​</a></h3>
<p>I will not attempt to define what is X beyond saying that is a concept. I know that X exists because I create instances of it whose particular formulations are different from each other.</p>
<p>So I'll naively assume that I can know X via instances of it, and perhaps know better the nature of X exploring and analyzing instances of it that boils down to the realm of language. In different languages the particular symbols and syntactic rules change but let's focus on the two languages I know better. Let's forget in this approach about strict grammatical rules so to advance faster. More strict consideration will not invalidate the main arguments.</p>
<ul>
<li>In Spanish we formulate a question simply by preappending a ¿ and postappending a ? symbols to a sentence: ¿Es esto una pregunta? Respuesta: Sí</li>
<li>In English, let's simplify and formulate the question using only the symbol ? at the end. Is this a question? Answer: Yes</li>
</ul>
<p>So there we have it. Let's explore X and their related Y's via instances of it. One particular interesting instance of it is the WIQ formulation:</p>
<p><strong>What is a question?</strong></p>
<p>Now I think is more clear to see that is a self-referential question. A particular instance of the concept that is asking for its own meaning. Is like X being forced (via me writing the formulation) to say: What am I? (Let's not question whether X is capable of instanciating itself or is only subjected to the will of the users of it, us, humans formulating questions... I'll assume the latter).</p>
<p>Ok, so now I have a mental model on which I can think about questions, i.e. A concept I can explore and analyze via instances of it that I formulate. And this heuristic turns out to be sufficient to give an answer to the WIQ.</p>
<p><strong>What is a question?</strong> Answer: It is a concept whose realization is via instances I formulate and can be explored analyzing those instances, the product of the analysis is one or more instances of connected information intended to further inform about the formulated question, we call these later instances answers.</p>
<p>Great, now I have a better mental model to explore questions!!!</p>
<p>For example, will programming web applications be completely automated?</p>
<p>Thinking of a question as a concept whose nature can be examined via particular instances of it, we can see that this particular question is an instance of a concept whose nature can be examined via particular instances of formulated questions. In this case the instance is: <em>Will programming web applications be completely automated?</em></p>
<p>Each question instantiated can be related to multiple instance questions whose core concept is the same. Answering those questions will inform more about the nature of the concepts I'm trying to know about. I'm not saying that all knowledge should ultimately be a concept that abstracts an intuition or perception, but I'm saying that we can try to condensate information towards concepts via questions and see the whole process as an exploration of an unknown abstract idea.</p>
<p>Now with solid mental model to explore and analyze questions, and one that encourages us to think about answering question as an explorative and always expanding process, fearless of uncertainty instead of static answers.</p>]]></content>
        <author>
            <name>Rogelio Lozano</name>
            <uri>https://github.com/RogelioLozano</uri>
        </author>
        <category label="epistemology" term="epistemology"/>
        <category label="logic" term="logic"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Is frontend automation near?]]></title>
        <id>https://rogeliolozano.github.io/blog/Automating-frontend</id>
        <link href="https://rogeliolozano.github.io/blog/Automating-frontend"/>
        <updated>2024-03-11T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Will programming web applications be completely automated?]]></summary>
        <content type="html"><![CDATA[<p>Will programming web applications be completely automated?</p>
<p>Though question to answer. So let's analyze it and try to formulate a good response. The idea that comes to my mind to start exploring the landscape consists in approaching a principled consideration in order to accumulate knowledge and arrive to an informed conclusion.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="historical-perspective">Historical perspective<a href="https://rogeliolozano.github.io/blog/Automating-frontend#historical-perspective" class="hash-link" aria-label="Direct link to Historical perspective" title="Direct link to Historical perspective">​</a></h3>
<p>I'll just divide the pharagraphs for order of gradual evolution but was not a sequential process, all the advancements overlap in time, space, and industry axes.</p>
<p>First, Alan Turing, John Von Neumann, among others developed the foundational concepts of computing and programming. This was a highly manual job, deep <em>understanding</em> of computer's architecture was required.</p>
<p>Second, advances in early machine code for specific computer architectures. Team led by Maurice Wilkes developed the concept of microprogramming (<a href="https://dl.acm.org/doi/10.1145/1458043.1458047" target="_blank" rel="noopener noreferrer">https://dl.acm.org/doi/10.1145/1458043.1458047</a>). A method of implementing the behavior of machine instructions by means of more elementary operations, with direct correspondence with the functions of the physical components of the computer. The control of instructions was hardwired, composed of circuits that corresponds with execution of each instruction. This was difficult to <em>modify</em>, expensive to <em>design</em> but fast. Microprogrammed allowed for simpler designs, easier to modify but slower than hardwired control.</p>
<p>Assembly language emerged as a symbolic representation of machine code instructions. Instead of seeing addresses of instructions, programmers saw <em>abstract</em> symbols for instructions like read from memory, store into register rsp, etc.. This was easier to <em>understand</em>, <em>modify</em> and <em>maintain</em> as compared to raw machine code. Still, it was architecture instruction set dependent.</p>
<p>Then, the emergence of higher-level programming languages. With all the widely known advantages in <em>portability</em>, <em>understanding</em>, <em>maintainability</em>, among others. For what I know, assembly is possible only used for critical performance, systems programming, operating system development and embedded systems nowadays.</p>
<h3></h3>
<p>Now, is very general, because for what I know, changes happened gradually and at different phases in different industries and at different scales.</p>]]></content>
        <author>
            <name>Rogelio Lozano</name>
            <uri>https://github.com/RogelioLozano</uri>
        </author>
        <category label="AI" term="AI"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Mental methods to solve problems]]></title>
        <id>https://rogeliolozano.github.io/blog/Solving-logical-problems</id>
        <link href="https://rogeliolozano.github.io/blog/Solving-logical-problems"/>
        <updated>2024-03-05T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[To start smoothly, I'll share ideas I consider important to keep in mind when hunting counterexamples and rapidly discard conjectures that will go nowhere when solving difficult logical-constructive problems. Almost anyone subconsciously does think in two or three of these approaches, but it is useful to have a reminder of these methods of thinking.]]></summary>
        <content type="html"><![CDATA[<p>To start smoothly, I'll share ideas I consider important to keep in mind when hunting counterexamples and rapidly discard conjectures that will go nowhere when solving difficult logical-constructive problems. Almost anyone subconsciously does think in two or three of these approaches, but it is useful to have a reminder of these methods of thinking.</p>
<ul>
<li>
<p>Think small – Start with small examples because they are easier to construct and reason about and allow you to grasp the fundamental ideas that are in the core structure of the problem.</p>
</li>
<li>
<p>Think exhaustively – There are usually only a small number of possible instances for the first non-trivial value of n. For example, there are only three distinct ways two intervals on the line can occur: as disjoint intervals, as overlapping intervals, and as properly nesting intervals, one within the other. All cases of three intervals can be systematically constructed by adding a third segment in each possible way to these three instances.</p>
</li>
<li>
<p>Hunt for the weakness – If a proposed algorithm is of the form “always take the biggest” (better known as the greedy algorithm), think about why that might prove to be the wrong thing to do.</p>
</li>
<li>
<p>Go for a tie – A devious way to break a greedy heuristic for example is to provide instances where everything is the same size. Suddenly the heuristic has nothing to base its decision on, and perhaps has the freedom to return something suboptimal as the answer.</p>
</li>
<li>
<p>Seek extremes – Many counter-examples are mixtures of huge and tiny, left and right, few and many, near and far. It is usually easier to verify or reason about extreme examples than more muddled ones.</p>
</li>
<li>
<p>Divide and conquer - A classical mental model to approach problems that can be divided into subproblems of smaller data size. The resulting structure after applying the method is usually a recursive tree where each node has the subproblem of smaller data size. One classical Example is MergeSort (with a runtime complexity of O(nlog(n)))</p>
</li>
</ul>]]></content>
        <author>
            <name>Rogelio Lozano</name>
            <uri>https://github.com/RogelioLozano</uri>
        </author>
        <category label="mental methods" term="mental methods"/>
    </entry>
</feed>